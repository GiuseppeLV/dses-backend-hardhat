{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  // solhint-disable-next-line chainlink-solidity/all-caps-constant-storage-variables\n  uint256 internal constant defaultBufferSize = 256;\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function _initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function _setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function _add(Request memory self, string memory key, string memory value) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function _addBytes(Request memory self, string memory key, bytes memory value) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function _addInt(Request memory self, string memory key, int256 value) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function _addUint(Request memory self, string memory key, uint256 value) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function _addStringArray(Request memory self, string memory key, string[] memory values) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Chainlink} from \"./Chainlink.sol\";\nimport {ENSInterface} from \"./interfaces/ENSInterface.sol\";\nimport {LinkTokenInterface} from \"./shared/interfaces/LinkTokenInterface.sol\";\nimport {ChainlinkRequestInterface} from \"./interfaces/ChainlinkRequestInterface.sol\";\nimport {OperatorInterface} from \"./interfaces/OperatorInterface.sol\";\nimport {PointerInterface} from \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\n// solhint-disable custom-errors\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10 ** 18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function _buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req._initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function _buildOperatorRequest(\n    bytes32 specId,\n    bytes4 callbackFunctionSignature\n  ) internal view returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req._initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function _sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return _sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function _sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function _sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return _sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function _sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n    return requestId;\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function _cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function _getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function _setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function _setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function _setPublicChainlinkToken() internal {\n    _setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function _chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function _chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function _addChainlinkExternalRequest(\n    address oracleAddress,\n    bytes32 requestId\n  ) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function _useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    _setChainlinkToken(resolver.addr(linkSubnode));\n    _updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function _updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    _setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function _validateChainlinkCallback(\n    bytes32 requestId\n  )\n    internal\n    recordChainlinkFulfillment(requestId) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {OracleInterface} from \"./OracleInterface.sol\";\nimport {ChainlinkRequestInterface} from \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/ChainlinkTools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport {Chainlink, ChainlinkClient} from \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\n\ncontract ChainlinkTools is ChainlinkClient, ConfirmedOwner {\n    using Chainlink for Chainlink.Request;\n    uint256 public volume;\n    bytes32 private jobId;\n    uint256 private fee;\n\n    event RequestPopulation(bytes32 indexed requestId, uint256 volume);\n\n    constructor() ConfirmedOwner(msg.sender) {\n        _setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789); //sepolia testnet\n        _setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);\n        jobId = \"ca98366cc7314957b8c012c72f05aeeb\";\n        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)\n    }\n\n    function RequestPopulationData(\n        string memory apiUrl //l'iso definito in nextjs\n    ) public returns (bytes32 requestId) {\n        Chainlink.Request memory req = _buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfill.selector\n        );\n\n        // Set the URL to perform the GET request on\n        req._add(\"get\", apiUrl);\n\n        req._add(\"path\", \"1,0,value\");\n        req._addInt(\"times\", 1);\n        return _sendChainlinkRequest(req, fee);\n    }\n\n    function fulfill(\n        bytes32 _requestId,\n        uint256 _volume\n    ) public recordChainlinkFulfillment(_requestId) {\n        emit RequestPopulation(_requestId, _volume);\n        volume = _volume;\n    }\n\n    function balanceof() public view returns (uint256) {\n        LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());\n        return link.balanceOf(msg.sender);\n    }\n\n    function balanceofContract() public view returns (uint256) {\n        LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());\n        return link.balanceOf(address(this));\n    }\n\n    function fundContract() public {\n        LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());\n        link.transfer(address(this), 15 * 10 ** 18);\n    }\n\n    function withdrawLink() public onlyOwner {\n        LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());\n        require(\n            link.transfer(msg.sender, link.balanceOf(address(this))),\n            \"Unable to transfer\"\n        );\n    }\n}\n"
    },
    "contracts/CityCitizen.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"./Classes.sol\";\n//import {IDSESCenter} from \"./DSESCenter.sol\";\nimport \"./interfaces/IDSESCenter.sol\";\nimport \"./interfaces/IPollutionToken.sol\";\nimport \"./interfaces/IPollutionNft.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {methods} from \"./Library.sol\";\n\ncontract CityCitizen is Initializable {\n    //for login purposes\n\n    mapping(address => classes.Citizen) private citizens;\n    mapping(address => classes.Industry) private industries;\n    uint256 private constant multiplier = 10 ** 18; //18 are the decimals\n    IPollutionToken private pt;\n    address private admin;\n    IDSESCenter private dsesCenter;\n    IPollutionNft private pnft;\n    event NoTokenCitizen(address indexed citizenAddr);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IPollutionToken ptContractAddress,\n        IDSESCenter dsesCenterAddress,\n        IPollutionNft pnftAddress\n    ) public initializer {\n        admin = msg.sender;\n        pt = ptContractAddress;\n        pnft = pnftAddress;\n        dsesCenter = dsesCenterAddress;\n        pnft.storeContractAddress(address(this), msg.sender);\n        pt.storeContractAddress(address(this), msg.sender);\n    }\n\n    function updateContractAddress(address newAddr) public onlyAdmin {\n        //used when redeployed only PollutionToken contract\n        pt = IPollutionToken(newAddr);\n        pt.storeContractAddress(address(this), msg.sender);\n    }\n\n    function getContractAddress() public view returns (address) {\n        return address(pt);\n    }\n\n    function getThisAddress() public view returns (address) {\n        return address(this);\n    }\n\n    function getAdminAddress() public view returns (address) {\n        return admin;\n    }\n\n    function addCitizen(\n        string memory name,\n        address citizenAddr,\n        uint256 checkedTimestamp,\n        string memory surname,\n        string memory email,\n        string memory dateOfBirth,\n        uint256 telephone,\n        string memory physicalAddress\n    ) public {\n        require(\n            dsesCenter.checkExistingCity(msg.sender) &&\n                !checkExistingCitizen(citizenAddr),\n            \"You are not a city or citizen already exist\"\n        );\n\n        //uint256 tokensAssigned = tokenToBeAssigned(); //this is omitted for semplicity and testing and it is used a constant value\n        //uint256 tokensAssigned = 30 * multiplier;\n        pt.transferForCities(msg.sender, citizenAddr, tokenToBeAssigned());\n        uint256 id = pt.getUserCount();\n        citizens[citizenAddr] = classes.Citizen(\n            name,\n            checkedTimestamp,\n            surname,\n            email,\n            dateOfBirth,\n            telephone,\n            physicalAddress,\n            id\n        );\n        //\n    }\n\n    function tokenToBeAssigned() public view returns (uint256) {\n        /*\n        classes.City memory city = dsesCenter.getCityByAddr(msg.sender);\n        return\n            (pt.getBalanceOf(msg.sender) / //balanceOfCity/(cityPopulation+20*cityNumberOfIndustries). 20 is an arbitrary number, just to allocate more tokens to industries\n                (city.population + 20 * city.numberOfIndustries)) * multiplier; //getCityByAddr used because A struct is an example of a dynamically sized type that can only be passed around internally\n    */\n        return 30 * multiplier;\n    }\n\n    function consumePTFromCitizen(uint256 amountUsed, address sender) public {\n        checkForExpiredToken(sender);\n        if (pt.getBalanceOf(msg.sender) != 0) {\n            pt.transferExtended(\n                //msg.sender,\n                sender,\n                //pt.getPreviousSender(msg.sender),\n                pt.getPreviousSender(sender),\n                amountUsed * multiplier //can be also used a formula to calculate the amount of token to transfer\n            );\n        } else {\n            //emit NoTokenCitizen(msg.sender);\n            emit NoTokenCitizen(sender);\n        }\n    }\n\n    function returnBalanceOfCitizen() public view returns (uint256) {\n        return pt.getBalanceOf(msg.sender);\n    }\n\n    function checkForExpiredToken(address sender) private {\n        if (\n            (block.timestamp - citizens[sender].checkedTimestamp) >= //check if 30 days as passed\n            methods.dayTimestamp(30)\n        ) {\n            //uint256 balanceOfCitizen = pt.getBalanceOf(msg.sender);\n            uint256 balanceOfCitizen = pt.getBalanceOf(sender);\n            checkForNft(balanceOfCitizen, sender);\n            pt.transferExtended(\n                //pt.getPreviousSender(msg.sender),\n                pt.getPreviousSender(sender),\n                //msg.sender,\n                sender,\n                tokenToBeAssigned() - balanceOfCitizen //example: 30 fixed tokens - 17 of balanceOfCitizen=13 token to be refilled to the citizen\n            ); //return back to the state the tokens remained\n            // citizens[msg.sender].checkedTimestamp = block.timestamp; //update citizen timestamp with the new timestamp of the actual date\n            citizens[sender].checkedTimestamp = block.timestamp;\n        }\n    }\n\n    function getCitizen(\n        address citizenAddr\n    ) public view returns (classes.Citizen memory) {\n        return citizens[citizenAddr];\n    }\n\n    function checkForNft(uint256 balanceOfCitizen, address sender) public {\n        //modify to private after testing\n        {\n            //uint256 balanceOfCitizen = pt.getBalanceOf(msg.sender);\n            if (\n                (balanceOfCitizen > 5 * multiplier) &&\n                (balanceOfCitizen <= 10 * multiplier)\n            ) //5 and 10 are random numbers, we want to check that 5<=balanceOfCitizen<=10 Pollution tokens\n            {\n                //pnft.mintNftCitizen(msg.sender, 0); //level 1 nft\n                pnft.mintNftCitizen(sender, 0);\n            } else if (\n                (balanceOfCitizen > 10 * multiplier) &&\n                (balanceOfCitizen <= 20 * multiplier)\n            ) {\n                //pnft.mintNftCitizen(msg.sender, 1);\n                pnft.mintNftCitizen(sender, 1);\n            }\n        }\n    }\n\n    function getPreviousSender() public view returns (address) {\n        return pt.getPreviousSender(msg.sender);\n    }\n\n    function returnBalanceOf() public view returns (uint256) {\n        return pt.getBalanceOf(msg.sender);\n    }\n\n    //PROVA AD EREDITARE METODI PER I CHECK, USA EREDIT CONTRATTI\n    function checkExistingCitizen(\n        address citizenAddr\n    ) public view returns (bool) {\n        return bytes(citizens[citizenAddr].name).length > 0;\n    }\n\n    function deleteCitizen(address citizenAddr) public onlyCity {\n        pt.transferExtended(\n            citizenAddr,\n            msg.sender,\n            pt.getBalanceOf(citizenAddr)\n        );\n        delete citizens[citizenAddr];\n    }\n\n    function returncheckedTimestamp() public view returns (bool) {\n        return\n            block.timestamp - citizens[msg.sender].checkedTimestamp >\n            methods.dayTimestamp(30);\n    }\n\n    function returnBlockTimestamp() public view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function returnNewTimestamp() public view returns (uint256) {\n        return citizens[msg.sender].checkedTimestamp;\n    }\n\n    modifier onlyCity() {\n        require(\n            dsesCenter.checkExistingCity(msg.sender),\n            \"You are not allowed to do that. You are not a city\"\n        );\n        _;\n    }\n    modifier onlyAdmin() {\n        require(\n            (msg.sender == admin),\n            \"You are not the owner of this contract\"\n        );\n        _;\n    }\n\n    modifier checkMonthHasPassed() {\n        if (\n            (block.timestamp - citizens[msg.sender].checkedTimestamp) >=\n            methods.dayTimestamp(30)\n        ) _;\n    }\n}\n"
    },
    "contracts/CityIndustry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"./Classes.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {methods} from \"./Library.sol\";\nimport \"./interfaces/IDSESCenter.sol\";\nimport \"./interfaces/IPollutionToken.sol\";\nimport \"./interfaces/IPollutionNft.sol\";\n\ncontract CityIndustry is Initializable {\n    //for login purposes\n    mapping(address => classes.Industry) private industries;\n    uint256 private constant multiplier = 10 ** 18; //18 are the decimals\n    IPollutionToken private pt;\n    address private admin;\n    IDSESCenter private dsesCenter;\n    IPollutionNft private pnft;\n    event NoTokenIndustry(address indexed industryAddr);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IPollutionToken ptContractAddress,\n        IDSESCenter dsesCenterAddress,\n        IPollutionNft pnftAddress\n    ) public initializer {\n        admin = msg.sender;\n        pt = ptContractAddress;\n        pnft = pnftAddress;\n        dsesCenter = dsesCenterAddress;\n        pnft.storeContractAddress(address(this), msg.sender);\n        pt.storeContractAddress(address(this), msg.sender);\n    }\n\n    function getContractAddress() public view returns (address) {\n        return address(pt);\n    }\n\n    function getThisAddress() public view returns (address) {\n        return address(this);\n    }\n\n    function getAdminAddress() public view returns (address) {\n        return admin;\n    }\n\n    function consumePTFromIndustry(\n        //used by industries and Industry\n        uint256 amountUsed\n    ) public {\n        if (pt.getBalanceOf(msg.sender) != 0) {\n            pt.transferExtended(\n                msg.sender,\n                pt.getPreviousSender(msg.sender),\n                amountUsed //can be also used a formula to calculate the amount of token to transfer\n            );\n        } else {\n            emit NoTokenIndustry(msg.sender);\n        }\n    }\n\n    function addIndustry(\n        string memory name,\n        address industryAddr,\n        uint256 registrationTimestamp\n    ) public {\n        require(\n            dsesCenter.checkExistingCity(msg.sender) &&\n                !checkExistingIndustry(industryAddr),\n            \"You are not a city or industry already exist\"\n        );\n\n        industries[industryAddr] = classes.Industry(\n            name,\n            registrationTimestamp\n        );\n        // uint256 tokensAssigned = tokensToBeAssigned(); //this is omitted for semplicity and testing and it is used a constant value\n        uint256 tokensAssigned = 50 * multiplier;\n        pt.transferExtended(msg.sender, industryAddr, tokensAssigned);\n    }\n\n    function tokensToBeAssigned() public view returns (uint256) {\n        classes.City memory city = dsesCenter.getCityByAddr(msg.sender);\n        return\n            ((20 * pt.getBalanceOf(msg.sender)) / //balanceOfCity/(cityPopulation+20*cityNumberOfIndustries). 20 is an arbitrary number, just to allocate more tokens to industries\n                (city.population + 20 * city.numberOfIndustries)) * multiplier; //getCityByAddr used because A struct is an example of a dynamically sized type that can only be passed around internally\n    }\n\n    function checkForNft() public {\n        if (\n            (block.timestamp - industries[msg.sender].registrationTimestamp) >=\n            methods.dayTimestamp(30)\n        ) {\n            uint256 balanceOfIndustry = pt.getBalanceOf(msg.sender);\n            if (\n                balanceOfIndustry >= 5 * multiplier &&\n                balanceOfIndustry <= 10 * multiplier\n            ) //5 and 10 are random numbers, we want to check that 5<=balanceOfIndustry<=10 Pollution tokens\n            {\n                pnft.mintNftIndustry(msg.sender, 1); //level 1 nft\n            } else if (\n                balanceOfIndustry >= 11 * multiplier &&\n                balanceOfIndustry <= 30 * multiplier\n            ) {\n                pnft.mintNftIndustry(msg.sender, 2); //level 2 nft\n            }\n        }\n    }\n\n    function checkForExpiredToken() private checkMonthHasPassed {\n        {\n            uint256 balanceOfIndustry = pt.getBalanceOf(msg.sender);\n            if (balanceOfIndustry != 0) {\n                pt.transferExtended(\n                    msg.sender,\n                    pt.getPreviousSender(msg.sender),\n                    balanceOfIndustry\n                ); //return back to the state the tokens remained\n            } else {\n                pt.transferExtended(\n                    pt.getPreviousSender(msg.sender),\n                    msg.sender,\n                    50 * multiplier\n                    //tokenToBeAssigned() //this is omitted for semplicity and testing and it is used a constant value\n                );\n            }\n        }\n    }\n\n    function checkExistingIndustry(\n        address industryAddr\n    ) public view returns (bool) {\n        return bytes(industries[industryAddr].name).length > 0;\n    }\n\n    function deleteIndustry(address industryAddr) public onlyCity {\n        delete industries[industryAddr];\n    }\n\n    function checkForCity() public view returns (uint256) {\n        return dsesCenter.getCityByAddr(msg.sender).population;\n    }\n\n    modifier onlyCity() {\n        require(\n            dsesCenter.checkExistingCity(msg.sender),\n            \"You are not allowed to do that. You are not a City\"\n        );\n        _;\n    }\n\n    modifier checkMonthHasPassed() {\n        if (\n            (block.timestamp - industries[msg.sender].registrationTimestamp) >=\n            methods.dayTimestamp(30)\n        ) _;\n    }\n}\n"
    },
    "contracts/Classes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nlibrary classes {\n    struct State {\n        string name;\n        string iso;\n        int numberOfCities;\n        string attorneyName;\n        string attorneySurname;\n        string attorneyEmail;\n        uint256 telephone;\n        string physicalAddress;\n    }\n\n    struct City {\n        string name;\n        uint256 population;\n        uint256 numberOfIndustries;\n        string attorneyName;\n        string attorneySurname;\n        string attorneyEmail;\n        uint256 telephone;\n        string physicalAddress;\n    }\n\n    struct Citizen {\n        string name;\n        uint256 checkedTimestamp;\n        string surname;\n        string email;\n        string dateOfBirth;\n        uint256 telephone;\n        string physicalAddress;\n        uint256 id; //used for bip44 wallet\n    }\n    struct Industry {\n        string name;\n        uint256 registrationTimestamp;\n    }\n}\n"
    },
    "contracts/DSESCenter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\nimport \"./interfaces/IPollutionToken.sol\";\nimport \"./Classes.sol\";\nimport \"./ChainlinkTools.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ninterface IDSESCenter {\n    function getCityByAddr(\n        address cityAddr\n    ) external view returns (classes.City memory);\n\n    function checkExistingCity(address cityAddr) external view returns (bool);\n}\n\ncontract DSESCenter is Initializable {\n    address private admin;\n    IPollutionToken private pt;\n    ChainlinkTools private ct;\n    uint256 private constant INITIAL_SUPPLY = 100000;\n    uint256 private constant multiplier = 10 ** 18;\n    uint256 private userCount;\n    mapping(address => classes.State) private states; //for login purposes\n    mapping(address => classes.City) private cities;\n\n    error DSESCenter__Only_State_Allowed();\n    error DSESCenter__Only_Admin_Allowed();\n\n    function increaseUserCount() public returns (uint256) {\n        userCount = userCount + 1;\n        return userCount;\n    }\n\n    /*\n    constructor(PollutionToken ptContractAddress) {\n        admin = msg.sender;\n        pt = ptContractAddress;\n        pt.storeContractAddress(address(this), msg.sender);\n        ct = new ChainlinkTools();\n    }\n*/\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(IPollutionToken ptContractAddress) public initializer {\n        admin = msg.sender;\n        pt = ptContractAddress;\n        pt.storeContractAddress(address(this), msg.sender);\n        ct = new ChainlinkTools();\n    }\n\n    function checkExistingAdmin(address adminAddr) public view returns (bool) {\n        return adminAddr == admin ? true : false;\n    }\n\n    function updateContractAddress(address newAddr) public onlyAdmin {\n        //DEPRECATED\n        //used when redeployed only PollutionToken contract\n        pt = IPollutionToken(newAddr);\n        pt.storeContractAddress(address(this), msg.sender);\n    }\n\n    function getCityByAddr(\n        address cityAddr\n    ) public view returns (classes.City memory) {\n        return cities[cityAddr];\n    }\n\n    function getContractAddress() public view returns (address) {\n        return address(pt);\n    }\n\n    function getThisAddress() public view returns (address) {\n        return address(this);\n    }\n\n    function addState(\n        //FAI DEI TEST GAS USANDO MEMORY E CLASSE DERIVATA E SENZA CLASSE DERIVATA\n        string memory name,\n        string memory iso,\n        address stateAddr,\n        int numberOfCities,\n        string memory attorneyName,\n        string memory attorneySurname,\n        string memory attorneyEmail,\n        uint256 telephone,\n        string memory physicalAddress\n    ) external {\n        //only callable by admin\n\n        require(\n            (msg.sender == admin) && (!checkExistingState(stateAddr)),\n            \"Error while adding a new state. Maybe you are not the owner or the state already exist\"\n        );\n        states[stateAddr] = classes.State(\n            name,\n            iso,\n            numberOfCities,\n            attorneyName,\n            attorneySurname,\n            attorneyEmail,\n            telephone,\n            physicalAddress\n        );\n\n        pt.transferExtended(msg.sender, stateAddr, 30000 * multiplier); //modificable}\n    }\n\n    function deleteState(address stateAddr) external onlyAdmin {\n        delete states[stateAddr];\n    }\n\n    function getState(\n        address stateAddr\n    ) public view returns (classes.State memory) {\n        return states[stateAddr];\n    }\n\n    function getStateName(\n        address stateAddr\n    ) public view returns (string memory) {\n        return states[stateAddr].name;\n    }\n\n    function getStateNumber(address stateAddr) public view returns (uint256) {\n        return states[stateAddr].telephone;\n    }\n\n    function checkExistingState(address addr) public view returns (bool) {\n        return bytes(states[addr].name).length > 0; //mapping are initialized as 0.\n    }\n\n    function transferToState(\n        address stateAddrDestination,\n        uint256 amount\n    ) external onlyState {\n        pt.transferExtended(msg.sender, stateAddrDestination, amount);\n    }\n\n    function addCity(\n        string memory name,\n        uint256 population,\n        uint256 numberOfIndustries,\n        address cityAddr,\n        string memory attorneyName,\n        string memory attorneySurname,\n        string memory attorneyEmail,\n        uint256 telephone,\n        string memory physicalAddress\n    ) external {\n        require(\n            checkExistingState(msg.sender) && !checkExistingCity(cityAddr),\n            \"Error while adding a new city. Maybe you are not a state or the city already exist\"\n        );\n\n        cities[cityAddr] = classes.City(\n            name,\n            population,\n            numberOfIndustries,\n            attorneyName,\n            attorneySurname,\n            attorneyEmail,\n            telephone,\n            physicalAddress\n        );\n        /*\n        uint256 tokenAssigned = (\n            (pt.getBalanceOf(msg.sender) / states[msg.sender].numberOfCities)\n        ) * multiplier; //#(tokenState/numberOfCitiesState)/cityPopulation\n        */\n        uint256 tokenAssigned = 1000 * multiplier;\n        pt.transferExtended(msg.sender, cityAddr, tokenAssigned);\n    }\n\n    function checkExistingCity(address cityAddr) public view returns (bool) {\n        return bytes(cities[cityAddr].name).length > 0; //mapping are initialized as 0.\n    }\n\n    function deleteCity(address cityAddr) external onlyState {\n        delete cities[cityAddr];\n    }\n\n    function getCityName(address cityAddr) public view returns (string memory) {\n        return cities[cityAddr].name;\n    }\n\n    function getCity(\n        address cityAddr\n    ) public view returns (classes.City memory) {\n        return cities[cityAddr];\n    }\n\n    function getBalanceOf(address addr) public view returns (uint256) {\n        return pt.getBalanceOf(addr);\n    }\n\n    function getMsgSenderAddr() public view returns (address) {\n        return msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        if ((msg.sender != admin)) {\n            revert DSESCenter__Only_Admin_Allowed();\n        }\n        _;\n    }\n\n    modifier onlyState() {\n        if ((!checkExistingState(msg.sender))) {\n            revert DSESCenter__Only_State_Allowed();\n        }\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IDSESCenter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\nimport \"../Classes.sol\";\n\ninterface IDSESCenter {\n    function getCityByAddr(\n        address cityAddr\n    ) external view returns (classes.City memory);\n\n    function checkExistingCity(address cityAddr) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPollutionNft.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\ninterface IPollutionNft {\n    function mintNftIndustry(address to, uint256 level) external;\n\n    function storeContractAddress(\n        address contractAddr,\n        address sender\n    ) external;\n\n    function mintNftCitizen(address to, uint256 level) external;\n}\n"
    },
    "contracts/interfaces/IPollutionToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\ninterface IPollutionToken {\n    function transferExtended(address from, address to, uint256 value) external;\n\n    function getPreviousSender(address from) external view returns (address);\n\n    function storeContractAddress(\n        address contractAddr,\n        address sender\n    ) external;\n\n    function getBalanceOf(address addr) external view returns (uint256);\n\n    function transferForCities(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    function getUserCount() external view returns (uint256);\n}\n"
    },
    "contracts/Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nlibrary methods {\n    function dayTimestamp(\n        uint256 numberOfDays\n    ) internal pure returns (uint256) {\n        return numberOfDays * 86400; //86400 is the number of seconds in one day\n    }\n}\n"
    },
    "contracts/PollutionToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ninterface tokenRecipient {\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes calldata _extraData\n    ) external;\n}\n\nerror PollutionToken__Only_Allowed_Contracts();\n\ncontract PollutionToken is Initializable {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n    address private admin;\n    uint256 private userCount;\n    mapping(address => address) contractAddresses; //used to store contract addresses allowed by admin that interact with this contract\n\n    // This creates an array with all balances\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => address) public reversePartecipants; //used for the transfer from citizens/industry back to city and from city to state\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This generates a public event on the blockchain that will notify clients\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n\n    /*\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) {\n        totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\n        admin = msg.sender;\n        name = tokenName; // Set the name for display purposes\n        symbol = tokenSymbol; // Set the symbol for display purposes\n    }*/\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public initializer {\n        decimals = 18;\n        totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\n        admin = msg.sender;\n        name = tokenName; // Set the name for display purposes\n        symbol = tokenSymbol; // Set the symbol for display purposes\n    }\n\n    function getAdminAddress() public view returns (address) {\n        return admin;\n    }\n\n    function getBalanceOf(address addr) public view returns (uint256) {\n        return balanceOf[addr];\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferExtended(\n        address from,\n        address to,\n        uint256 value\n    ) public onlyAllowedContracts {\n        _transfer(from, to, value);\n    }\n\n    function transferForCities(\n        address from,\n        address to,\n        uint256 value\n    ) public onlyAllowedContracts {\n        reversePartecipants[to] = from;\n        userCount = userCount + 1;\n        transferExtended(from, to, value);\n    }\n\n    function getUserCount() public view returns (uint256) {\n        return userCount;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        //require(_value <= allowance[_from][msg.sender]); // Check allowance\n        require(\n            (_value <= allowance[_from][_to]) &&\n                contractAddresses[msg.sender] == admin,\n            \"you are not allowed to do transferFrom function\"\n        );\n        //allowance[_from][msg.sender] -= _value;\n        allowance[_from][_to] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function getPreviousSender(address from) public view returns (address) {\n        return reversePartecipants[from];\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(\n        address _spender,\n        uint256 _value\n    ) public returns (bool success) {\n        //allowance[msg.sender][_spender] = _value;\n        require(contractAddresses[msg.sender] == admin, \"you are not approved\");\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function storeContractAddress(address contractAddr, address sender) public {\n        //sender will be msg.sender that has to be the admin\n        require(\n            sender == admin,\n            \"you are not allowed to do that, you are not the admin\"\n        );\n        contractAddresses[contractAddr] = sender;\n    }\n\n    function getContractAddress() public view returns (address) {\n        return msg.sender;\n    }\n\n    function approveExtended(\n        address giver,\n        address _spender,\n        uint256 _value\n    ) public returns (bool success) {\n        //allowance[msg.sender][_spender] = _value;\n        require(\n            contractAddresses[msg.sender] == admin,\n            \"you are not approved by the admin\"\n        );\n        allowance[giver][_spender] = _value;\n        emit Approval(giver, _spender, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(\n        address _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(\n                msg.sender,\n                _value,\n                address(this),\n                _extraData\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\n        totalSupply -= _value; // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function getAllowance(\n        address master,\n        address slave\n    ) public view returns (uint256) {\n        return allowance[master][slave];\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(\n        address _from,\n        uint256 _value\n    ) public returns (bool success) {\n        require(balanceOf[_from] >= _value); // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\n        balanceOf[_from] -= _value; // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance\n        totalSupply -= _value; // Update totalSupply\n        emit Burn(_from, _value); //updat\n        return true;\n    }\n\n    modifier onlyAllowedContracts() {\n        if (contractAddresses[msg.sender] != admin) {\n            revert PollutionToken__Only_Allowed_Contracts();\n        }\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}